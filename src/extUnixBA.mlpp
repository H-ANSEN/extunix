(** ExtUnixBA *)

type buffer =
    (int, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

HAVE MEMALIGN

(** {2 posix_memalign}

    {b Author:} Goswin von Brederlow *)

(** [memalign alignment size] creates a {!Bigarray.Array1.t} of [size] bytes,
    which data is aligned to [alignment] (must be a power of 2) *)
external memalign: int -> int -> buffer = "caml_extunix_memalign"

END

HAVE PREAD
(** {2 pread}

    {b Author:} Goswin von Brederlow *)

(** [all_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [all_pread] repeats the read operation until all characters have
    been read or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK or End-of-file but
    only ever returns 0 on End-of-file. Continues the read operation
    on EINTR. Raises an Unix.Unix_error exception in all other
    cases. *)
external unsafe_all_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_all_pread"

let all_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.all_pread"
  else unsafe_all_pread fd off buf

(** [single_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [single_pread] attempts to read only once. Returns the number of
    characters read or raises an Unix.Unix_error exception. Unlike the
    string variant of the same name there is no limit on the number of
    characters read. *)
external unsafe_single_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pread"

let single_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.single_pread"
  else unsafe_single_pread fd off buf

(** [pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Continues
    the read operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pread"

let pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.pread"
  else unsafe_pread fd off buf

(** [intr_pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [intr_pread] repeats the read operation until all characters have
    been read or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be read before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_intr_pread"

let intr_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.intr_pread"
  else unsafe_intr_pread fd off buf
END

HAVE PWRITE
(** {2 pwrite}

    {b Author:} Goswin von Brederlow *)

(** [all_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.
    
    [all_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Returns less than the number of
    characters requested on EAGAIN, EWOULDBLOCK but never 0. Continues
    the write operation on EINTR. Raises an Unix.Unix_error exception
    in all other cases. *)
external unsafe_all_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_all_pwrite"

let all_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.all_pwrite"
  else unsafe_all_pwrite fd off buf

(** [single_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [single_pwrite] attempts to write only once. Returns the number of
    characters written or raises an Unix.Unix_error exception. Unlike
    the string variant of the same name there is no limit on the
    number of characters written. *)
external unsafe_single_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pwrite"

let single_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.single_pwrite"
  else unsafe_single_pwrite fd off buf

(** [pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Continues
    the write operation on EINTR. Returns the number of characters
    written in all other cases. *)
external unsafe_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pwrite"

let pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.pwrite"
  else unsafe_pwrite fd off buf

(** [intr_pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    [intr_pwrite] repeats the write operation until all characters have
    been written or an error occurs. Raises an Unix.Unix_error exception
    if 0 characters could be written before an error occurs. Does NOT
    continue on EINTR. Returns the number of characters written in all
    other cases. *)
external unsafe_intr_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_intr_pwrite"

let intr_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnixBA.intr_pwrite"
  else unsafe_intr_pwrite fd off buf
END

(** File operations on large files *)
module LargeFile =
struct

  (** File operations on large files. This sub-module provides 64-bit
      variants of the functions ExtUnixBA.all_pread,
      ExtUnixBA.single_pread, ExtUnixBA.pread, ExtUnixBA.intr_pread,
      ExtUnixBA.all_pwrite, ExtUnixBA.single_pwrite, ExtUnixBA.pwrite
      and ExtUnixBA.intr_pwrite (for reading from or writing to a file
      descriptor at a given offset). These alternate functions
      represent positions and sizes by 64-bit integers (type int64)
      instead of regular integers (type int), thus allowing operating
      on files whose sizes are greater than max_int. *)
  HAVE PREAD
  external unsafe_all_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_all_pread64"

  let all_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.all_pread"
    else unsafe_all_pread fd off buf

  external unsafe_single_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pread64"

  let single_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.single_pread"
    else unsafe_single_pread fd off buf

  external unsafe_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pread64"

  let pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.pread"
    else unsafe_pread fd off buf

  external unsafe_intr_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_intr_pread64"

  let intr_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.intr_pread"
    else unsafe_intr_pread fd off buf
  END

  HAVE PWRITE
  external unsafe_all_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_all_pwrite64"
    
  let all_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.all_pwrite"
    else unsafe_all_pwrite fd off buf

  external unsafe_single_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pwrite64"

  let single_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.single_pwrite"
    else unsafe_single_pwrite fd off buf

  external unsafe_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pwrite64"
    
  let pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.pwrite"
    else unsafe_pwrite fd off buf

  external unsafe_intr_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_intr_pwrite64"
    
  let intr_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnixBA.LargeFile.intr_pwrite"
    else unsafe_intr_pwrite fd off buf
  END
end

module EndianBig = struct

HAVE ENDIAN
  (** {2 big endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_bu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_bs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_bu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_bs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_bs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_bs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_b32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_b64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

module EndianLittle = struct

HAVE ENDIAN
  (** {2 little endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_lu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_ls16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_lu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_ls31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_ls32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_ls64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_l32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_l64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

module EndianNet = EndianBig

module EndianHost = struct

  (** {2 host endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_hu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_hs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_hu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_hs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_hs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_hs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_h32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_h64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

end

(** [unsafe_get_substr buf off len] extracts the substring from buffer
    [buf] starting at offset [off] and length [len]. Bounds checking
    is not performed. Use with caution and only when the program logic
    guarantees that the access is within bounds.*)
external unsafe_get_substr : buffer -> int -> int -> string = "caml_extunixba_get_substr"

(** [get_substr buf off len] same as [unsafe_get_substr] but with
    bounds checking. *)
let get_substr buf off len =
  if off < 0 || len < 0 || off > Bigarray.Array1.dim buf - len
  then raise (Invalid_argument "index out of bounds");
  unsafe_get_substr buf off len

(** [unsafe_set_substr buf off str] stores the string in buffer [buf]
    starting at offset [off]. Bounds checking is not performed. Use
    with caution and only when the program logic guarantees that the
    access is within bounds.*)
external unsafe_set_substr : buffer -> int -> string -> unit = "caml_extunixba_set_substr"

(** [set_substr buf off str] same as [unsafe_set_substr] but with
    bounds checking. *)
let set_substr buf off str =
  if off < 0 || off > Bigarray.Array1.dim buf - String.length str
  then raise (Invalid_argument "index out of bounds");
  unsafe_set_substr buf off str

(* NB Should be after all 'external' definitions *)

(** {2 Meta} *)
(** [have name]
  @return indication whether function [name] is available
  - [Some true] if available
  - [Some false] if not available
  - [None] if not known

  e.g. [have "eventfd"]
*)
SHOW ME THE MONEY

