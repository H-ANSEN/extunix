(** ExtUnixBA *)

type buffer =
    (int, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t

HAVE MEMALIGN

(** {2 posix_memalign}

    {b Author:} Goswin von Brederlow *)

(** [memalign alignment size] creates a {!Bigarray.Array1.t} of [size] bytes,
    which data is aligned to [alignment] (must be a power of 2) *)
external memalign: int -> int -> buffer = "caml_extunix_memalign"

END

HAVE PREAD
(** {2 pread}

    {b Author:} Goswin von Brederlow *)

(** [pread fd off buf] reads up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.

    Return the number of characters actually read. [pread] repeats the
    read operation until all characters have been read or an error
    occurs. On error some data may or may not been read.

    On End-of-file the number of characters read is returned including
    but not limited to 0. Non-blocking files raise an Unix_error of
    EAGAIN if no characters could be read. *)
external unsafe_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pread"

let pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.pread"
  else unsafe_pread fd off buf

(** [single_pread fd off buf] - Same as pread, but attempts to
    read only once. Thus, if an error occurs, single_read guarantees
    that no data has been read. Unlike the string variant of the same
    name there is no limit on the number of characters read. *)
external unsafe_single_pread: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pread"

let single_pread fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.single_pread"
  else unsafe_single_pread fd off buf
END

HAVE PWRITE
(** {2 pwrite}

    {b Author:} Goswin von Brederlow *)

(** [pwrite fd off buf] writes up to [size of buf] bytes from file
    descriptor [fd] at offset [off] (from the start of the file) into
    the buffer [buf]. The file offset is not changed.
    
    Return the number of characters actually written. [pwrite] repeats
    the write operation until all characters have been written or an
    error occurs. On error some data may or may not been written.

    Non-blocking files raise an Unix_error of EAGAIN if no characters
    could be written. *)
external unsafe_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_pwrite"

let pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.pwrite"
  else unsafe_pwrite fd off buf

(** [single_pwrite fd off buf] - Same as pwrite, but attempts
    to write only once. Thus, if an error occurs, single_write
    guarantees that no data has been written. Unlike the string
    variant of the same name there is no limit on the number of
    characters written. *)
external unsafe_single_pwrite: Unix.file_descr -> int -> buffer -> int = "caml_extunixba_single_pwrite"

let single_pwrite fd off buf =
  if off < 0
  then invalid_arg "ExtUnix.single_pwrite"
  else unsafe_single_pwrite fd off buf
END

(** File operations on large files *)
module LargeFile =
struct

  (** File operations on large files. This sub-module provides 64-bit
      variants of the functions ExtUnix.pread, ExtUnix.single_pread,
      ExtUnix.pwrite and ExtUnix.single_pwrite (for reading from or
      writing to a file descriptor at a given offset). These alternate
      functions represent positions and sizes by 64-bit integers (type
      int64) instead of regular integers (type int), thus allowing
      operating on files whose sizes are greater than max_int. *)
  HAVE PREAD
  external unsafe_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pread64"

  let pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pread"
    else unsafe_pread fd off buf

  external unsafe_single_pread: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pread64"

  let single_pread fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pread"
    else unsafe_single_pread fd off buf
  END

  HAVE PWRITE
  external unsafe_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_pwrite64"
    
  let pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.pwrite"
    else unsafe_pwrite fd off buf

  external unsafe_single_pwrite: Unix.file_descr -> int64 -> buffer -> int = "caml_extunixba_single_pwrite64"

  let single_pwrite fd off buf =
    if off < Int64.zero
    then invalid_arg "ExtUnix.LargeFile.single_pwrite"
    else unsafe_single_pwrite fd off buf
  END
end

module EndianBig = struct

HAVE ENDIAN
  (** {2 big endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_bu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_bs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_bu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_bs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_bs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_bs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_b16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_b31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_b32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_b64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

module EndianLittle = struct

HAVE ENDIAN
  (** {2 little endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_lu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_ls16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_lu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_ls31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_ls32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_ls64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_l16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_l31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_l32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_l64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

END

end

module EndianNet = EndianBig

module EndianHost = struct

  (** {2 host endian functions}

      {b Author:} Goswin von Brederlow *)

  (** [unsafe_get_X buf off] extract integer of type [X] from a
      buffer [buf] starting at offset [off]. Unsigned types are 0
      extended and signed types are sign extended to fill the ocaml
      type.  Bounds checking is not performed. Use with caution and
      only when the program logic guarantees that the access is within
      bounds.

      Note: The 31bit functions extract a 32bit integer and return it
      as ocaml int. On 32bit platforms this can overflow as ocaml
      integers are 31bit signed there. No error is reported if this
      occurs. Use with care. *)
  external unsafe_get_uint8  : buffer -> int -> int = "caml_extunixba_get_u8"
  external unsafe_get_int8   : buffer -> int -> int = "caml_extunixba_get_s8"
  external unsafe_get_uint16 : buffer -> int -> int = "caml_extunixba_get_hu16"
  external unsafe_get_int16  : buffer -> int -> int = "caml_extunixba_get_hs16"
  external unsafe_get_uint31 : buffer -> int -> int = "caml_extunixba_get_hu31"
  external unsafe_get_int31  : buffer -> int -> int = "caml_extunixba_get_hs31"
  external unsafe_get_int32  : buffer -> int -> int32 = "caml_extunixba_get_hs32"
  external unsafe_get_int64  : buffer -> int -> int64 = "caml_extunixba_get_hs64"

  (** [get_X buf off] same as [unsafe_get_X] but with bounds checking. *)
  let get_uint8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint8 buf off

  let get_int8 buf off =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int8 buf off

  let get_uint16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint16 buf off

  let get_int16 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int16 buf off

  let get_uint31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_uint31 buf off

  let get_int31 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int31 buf off

  let get_int32 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int32 buf off

  let get_int64 buf off =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_get_int64 buf off

  (** [unsafe_set_X buf off v] stores the integer [v] as type [X] in a
      buffer [buf] starting at offset [off]. Bounds checking is not
      performed. Use with caution and only when the program logic
      guarantees that the access is within bounds.

      Note: The 31bit functions store an ocaml int as 32bit
      integer. On 32bit platforms ocaml integers are 31bit signed and
      will be sign extended to 32bit first. Use with care. *)
  external unsafe_set_uint8  : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_int8   : buffer -> int -> int -> unit = "caml_extunixba_set_8"
  external unsafe_set_uint16 : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_int16  : buffer -> int -> int -> unit = "caml_extunixba_set_h16"
  external unsafe_set_uint31 : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int31  : buffer -> int -> int -> unit = "caml_extunixba_set_h31"
  external unsafe_set_int32  : buffer -> int -> int32 -> unit = "caml_extunixba_set_h32"
  external unsafe_set_int64  : buffer -> int -> int64 -> unit = "caml_extunixba_set_h64"

  (** [set_X buf off v] same as [unsafe_set_X] but with bounds checking. *)
  let set_uint8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint8 buf off v

  let set_int8 buf off v =
    if off < 0 || off >= Bigarray.Array1.dim buf
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int8 buf off v

  let set_uint16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint16 buf off v

  let set_int16 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 2
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int16 buf off v

  let set_uint31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_uint31 buf off v

  let set_int31 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int31 buf off v

  let set_int32 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 4
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int32 buf off v

  let set_int64 buf off v =
    if off < 0 || off > Bigarray.Array1.dim buf - 8
    then raise (Invalid_argument "index out of bounds");
    unsafe_set_int64 buf off v

end

(* NB Should be after all 'external' definitions *)

(** {2 Meta} *)
(** [have name]
  @return indication whether function [name] is available
  - [Some true] if available
  - [Some false] if not available
  - [None] if not known

  e.g. [have "eventfd"]
*)
SHOW ME THE MONEY

