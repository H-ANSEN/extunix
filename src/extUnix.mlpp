(** ExtUnix *)

(** [Not_available "func"] may be raised by [ExtUnix.All.func]
    if the wrapped C function is not available on this platform *)
exception Not_available of string

HAVE FSYNC
external fsync : Unix.file_descr -> unit = "caml_extunix_fsync"
END

HAVE FDATASYNC
external fdatasync : Unix.file_descr -> unit = "caml_extunix_fdatasync"
END

HAVE EVENTFD
external eventfd : int -> Unix.file_descr = "caml_extunix_eventfd"
external eventfd_read : Unix.file_descr -> int64 = "caml_extunix_eventfd_read"
external eventfd_write : Unix.file_descr -> int64 -> unit = "caml_extunix_eventfd_write"
END

HAVE DIRFD
external dirfd : Unix.dir_handle -> Unix.file_descr = "caml_extunix_dirfd"
END

HAVE STATVFS
type statvfs = { vfs_bsize : int; vfs_blocks : int64; vfs_bfree : int64; vfs_inodes : int64; vfs_ifree : int64; }
external statvfs : string -> statvfs = "caml_extunix_statvfs"
external fstatvfs : Unix.file_descr -> statvfs = "caml_extunix_fstatvfs"
END

HAVE ATFILE
external openat : Unix.file_descr -> string -> Unix.open_flag list -> Unix.file_perm -> Unix.file_descr = "caml_extunix_openat"
external fstatat : Unix.file_descr -> string -> Unix.stats = "caml_extunix_fstatat"
external unlinkat : Unix.file_descr -> string -> bool -> unit = "caml_extunix_unlinkat"
let unlinkat dirfd ?(rmdir=false) name = unlinkat dirfd name rmdir
external renameat : Unix.file_descr -> string -> Unix.file_descr -> string -> unit = "caml_extunix_renameat"
external mkdirat : Unix.file_descr -> string -> int -> unit = "caml_extunix_mkdirat"
END

HAVE UNAME

(** uname
    {b Author:} Sylvain Le Gall [sylvain\@le-gall.net]
  *)
module Uname = struct
type t =
    {
      sysname:    string;
      nodename:   string;
      release:    string;
      version:    string;
      machine:    string;
    }

let to_string t =
  String.concat " " [ t.sysname; t.nodename; t.release; t.version; t.machine ]
end

external uname : unit -> Uname.t = "caml_extunix_uname"

END

HAVE FADVISE

(** {2 posix_fadvise}

{b Author:} Sylvain Le Gall *)

type advice =
  | POSIX_FADV_NORMAL     (** Indicates that the application has no advice to
                              give about its access pattern for the specified
                              data.  *)
  | POSIX_FADV_SEQUENTIAL (** The application expects to access the specified
                              data sequentially.  *)
  | POSIX_FADV_RANDOM     (** The specified data will be accessed in random
                              order.  *)
  | POSIX_FADV_NOREUSE    (** The specified data will be accessed only once.  *)
  | POSIX_FADV_WILLNEED   (** The specified data will be accessed in the near
                              future.  *) 
  | POSIX_FADV_DONTNEED   (** The specified data will not be accessed in the
                              near future.  *)

(**/**) (*camlp4 misplaces comments*) (**/**)

external fadvise: Unix.file_descr -> int -> int -> advice -> unit = "caml_extunix_fadvise"

END

HAVE FALLOCATE

(** {2 posix_fallocate} *)
(** Allocate disk space for file

    {b Author:} Sylvain Le Gall
  *)

(** [fallocate fd off len] allocates disk space to ensure that subsequent writes
    between [off] and [off + len] in [fd] will not fail because of lack of disk 
    space. The file size is modified if [off + len] is bigger than the current size.
  *)
external fallocate: Unix.file_descr -> int -> int -> unit = "caml_extunix_fallocate"

END

(** File operations on large files *)
module LargeFile =
struct

HAVE FADVISE
  external fadvise: Unix.file_descr -> int64 -> int64 -> advice -> unit = "caml_extunix_fadvise64"
END

HAVE FALLOCATE
  external fallocate: Unix.file_descr -> int64 -> int64 -> unit = "caml_extunix_fallocate64"
END

end

(** {2 ioctl} *)

(** Control the underlying device parameters of special files *)
module Ioctl = struct

HAVE SIOCGIFCONF
(** [siocgifconf sock], where [sock] is any socket, e.g. [socket PF_INET SOCK_DGRAM 0]
  @return the list of interfaces and corresponfing addresses *)
external siocgifconf : sock:Unix.file_descr -> (string * string) list = "caml_extunix_ioctl_siocgifconf"
END

HAVE TTY_IOCTL

(** Enable RTS/CTS (hardware) flow control. See CRTSCTS in tcsetattr(3). 
    {b FIXME this is likely to disappear when separate interface for [tcsetattr] and [tcgetattr] gets implemented} *)
external crtscts : Unix.file_descr -> int = "caml_extunix_crtscts"

(** Get the status of modem bits. See TIOCMGET in tty_ioctl(4). *)
external tiocmget : Unix.file_descr -> int = "caml_extunix_ioctl_TIOCMGET"

(** Set the status of modem bits. See TIOCMSET in tty_ioctl(4). *)
external tiocmset : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMSET"

(** Clear the indicated modem bits. See TIOCMBIC in tty_ioctl(4). *)
external tiocmbic : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIC"

(** Set the indicated modem bits. See TIOCMBIS in tty_ioctl(4). *)
external tiocmbis : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIS"

END

end (* module Ioctl *)

(** {2 Miscellaneous} *)

HAVE TTYNAME
external ttyname : Unix.file_descr -> string = "caml_extunix_ttyname"
END

HAVE CTERMID
(** Get controlling terminal name *)
external ctermid : unit -> string = "caml_extunix_ctermid"
END

HAVE PGID

(** [setpgid pid pgid] sets the process group of the process specified by [pid] to [pgid].
    If [pid] is zero, then the process ID of the calling process is used. If
    [pgid] is zero, then the PGID of the process specified by [pid] is made the same as its process ID. *)
external setpgid : int -> int -> unit = "caml_extunix_setpgid"

(** [getpgid pid] returns the PGID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getpgid : int -> int = "caml_extunix_getpgid"

(** [getsid pid] returns the session ID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getsid : int -> int = "caml_extunix_getsid"

END

HAVE SETREUID

(** [setreuid ruid euid] sets real and effective user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setreuid(2)" manual *)
external setreuid : int -> int -> unit = "caml_extunix_setreuid"

(** [setregid rgid egid] sets real and effective group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setregid(2)" manual *)
external setregid : int -> int -> unit = "caml_extunix_setregid"

END

HAVE REALPATH
(** [realpath path]
    @return the canonicalized absolute pathname of [path]
    @see "realpath(2)" manual *)
external realpath : string -> string = "caml_extunix_realpath"
END

HAVE FCNTL
(** @return whether file desctiptor is open *)
external is_open_descr : Unix.file_descr -> bool = "caml_extunix_is_open_descr"
END

HAVE TCPGRP
external tcgetpgrp : Unix.file_descr -> int = "caml_extunix_tcgetpgrp"
external tcsetpgrp : Unix.file_descr -> int -> unit = "caml_extunix_tcsetpgrp"
END

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let int_of_file_descr : Unix.file_descr -> int =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "int_of_file_descr")
  else
    Obj.magic

(** @raise Not_available if OS does not represent file descriptors as numbers *)
let file_descr_of_int : int -> Unix.file_descr =
  if Obj.is_block (Obj.repr Unix.stdin) then
    fun _ -> raise (Not_available "file_descr_of_int")
  else
    Obj.magic

HAVE SIGNALFD

(** {2 signalfd} *)

(** OCaml bindings for signalfd(2) and related functions

    {b Author:} Kaustuv Chaudhuri <kaustuv.chaudhuri\@inria.fr>
*)

(******************************************************************************)
(* signalfd bindings                                                          *)
(*                                                                            *)
(* NO COPYRIGHT -- RELEASED INTO THE PUBLIC DOMAIN                            *)
(*                                                                            *)
(* Author: Kaustuv Chaudhuri <kaustuv.chaudhuri@inria.fr>                     *)
(******************************************************************************)

(** [signalfd ?fd sigs flags ()]
    If the first optional argument is omitted, then a new file descriptor is allocated.
    Otherwise, the given file descriptor is modified (in which case it
    must have been created with [signalfd] previously). When you are
    done with the fd, remember to {!Unix.close} it. Do not forget
    to block [sigs] with {!Unix.sigprocmask} to prevent signal handling
    according to default dispositions.
    @see "signalfd(2)" manual
    *)
external signalfd : ?fd:Unix.file_descr -> sigs:int list -> flags:int list -> unit -> Unix.file_descr ="caml_extunix_signalfd"

(** This type represents signal information that is read(2) from the
    signalfd. *)
type ssi

(** Blocking read(2) on a signalfd. Has undefined behaviour on
    non-signalfds. Every successful read consumes a pending signal. *)
external signalfd_read    : Unix.file_descr -> ssi = "caml_extunix_signalfd_read"

(** {6 Functions to query the signal information structure.} *)

(** Get the signal value. This form is compatible with the signal
    values defined in the standard {!Sys} module.

    See signalfd(2) for the details of the remaining functions. Most
    of these integers are actually unsigned. *)
external ssi_signo_sys    : ssi -> int   = "caml_extunix_ssi_signo_sys"

external ssi_signo        : ssi -> int32 = "caml_extunix_ssi_signo"
external ssi_errno        : ssi -> int32 = "caml_extunix_ssi_errno"
external ssi_code         : ssi -> int32 = "caml_extunix_ssi_code"
external ssi_pid          : ssi -> int32 = "caml_extunix_ssi_pid"
external ssi_uid          : ssi -> int32 = "caml_extunix_ssi_uid"
external ssi_fd           : ssi -> Unix.file_descr = "caml_extunix_ssi_fd"
external ssi_tid          : ssi -> int32 = "caml_extunix_ssi_tid"
external ssi_band         : ssi -> int32 = "caml_extunix_ssi_band"
external ssi_overrun      : ssi -> int32 = "caml_extunix_ssi_overrun"
external ssi_trapno       : ssi -> int32 = "caml_extunix_ssi_trapno"
external ssi_status       : ssi -> int32 = "caml_extunix_ssi_status"
external ssi_int          : ssi -> int32 = "caml_extunix_ssi_int"
external ssi_ptr          : ssi -> int64 = "caml_extunix_ssi_ptr"
external ssi_utime        : ssi -> int64 = "caml_extunix_ssi_utime"
external ssi_stime        : ssi -> int64 = "caml_extunix_ssi_stime"
external ssi_addr         : ssi -> int64 = "caml_extunix_ssi_addr"

END

HAVE PTRACE

(** {2 ptrace} *)

external ptrace_traceme : unit -> unit = "caml_extunix_ptrace_traceme"
external ptrace_peekdata : int -> nativeint -> nativeint = "caml_extunix_ptrace_peekdata"
external ptrace_peektext : int -> nativeint -> nativeint = "caml_extunix_ptrace_peektext"

type ptrace_request =
  | PTRACE_ATTACH
  | PTRACE_DETACH

external ptrace : int -> ptrace_request -> unit = "caml_extunix_ptrace"

END

HAVE RESOURCE

(** 
  {2 POSIX resource operations}

  {b Author:} Sylvain Le Gall <sylvain\@le-gall.net>
*)

type which_prio_t =
  | PRIO_PROCESS of int (** Priority for a process id *)
  | PRIO_PGRP of int    (** Priority for a process group id *)
  | PRIO_USER of int    (** Priority for a user id *)

type priority = int

type resource =
  | RLIMIT_CORE   (** Limit on size of core dump file. *)
  | RLIMIT_CPU    (** Limit on CPU time per process. *)
  | RLIMIT_DATA   (** Limit on data segment size. *)
  | RLIMIT_FSIZE  (** Limit on file size. *)
  | RLIMIT_NOFILE (** Limit on number of open files. *)
  | RLIMIT_STACK  (** Limit on stack size. *)
  | RLIMIT_AS     (** Limit on address space size. *)

let string_of_resource = function
  | RLIMIT_CORE   -> "RLIMIT_CORE"
  | RLIMIT_CPU    -> "RLIMIT_CPU"
  | RLIMIT_DATA   -> "RLIMIT_DATA"
  | RLIMIT_FSIZE  -> "RLIMIT_FSIZE"
  | RLIMIT_NOFILE -> "RLIMIT_NOFILE"
  | RLIMIT_STACK  -> "RLIMIT_STACK"
  | RLIMIT_AS     -> "RLIMIT_AS"

(** Limits *)
module Rlimit = struct

  type t = int64 option (** [Some limit] is fixed limit, [None] is RLIM_INFINITY *)

  let string_of_bytes n =
    let sz, acc = List.fold_left (fun (sz, acc) e ->
      let q = Int64.div sz 1024L in
      let r = Int64.rem sz 1024L in
      let acc = if r <> 0L then Printf.sprintf "%Ld %s" r e :: acc else acc in
      (q, acc)) (n, []) ["B"; "KB"; "MB"; "GB"] 
    in
    let acc = if sz <> 0L then Printf.sprintf "%Ld TB" sz :: acc else acc in
    match acc with
    | [] -> "0 B"
    | _ -> String.concat " " acc

  let to_string ?r = function
  | None -> "infinity"
  | Some l ->
    match r with 
    | None -> Int64.to_string l
    | Some RLIMIT_CORE
    | Some RLIMIT_DATA 
    | Some RLIMIT_FSIZE
    | Some RLIMIT_STACK
    | Some RLIMIT_AS -> string_of_bytes l
    | Some RLIMIT_NOFILE -> Int64.to_string l
    | Some RLIMIT_CPU -> Printf.sprintf "%Ld s" l

  let compare l1 l2 =
    match l1, l2 with
    | Some l1, Some l2 -> Int64.compare l1 l2
    | None, None -> 0
    | Some _, None -> -1
    | None, Some _ -> 1

  let eq l1 l2 = compare l1 l2 = 0
  let gt l1 l2 = compare l1 l2 > 0
  let ge l1 l2 = compare l1 l2 >= 0
  let lt l1 l2 = compare l1 l2 < 0
  let le l1 l2 = compare l1 l2 <= 0

end (* Rlimit *)

(** Get nice value *)
external getpriority : which_prio_t -> priority = "caml_extunix_getpriority" 

(** Set nice value *)
external setpriority : which_prio_t -> priority -> unit = "caml_extunix_setpriority"

(** Get maximum resource consumption. @return [(soft,hard)] limits *)
external getrlimit : resource -> Rlimit.t * Rlimit.t = "caml_extunix_getrlimit"

(** Set maximum resource consumption *)
external setrlimit : resource -> soft:Rlimit.t -> hard:Rlimit.t -> unit = "caml_extunix_setrlimit"

(* let unlimit_soft r = let (_,hard) = getrlimit r in setrlimit r ~soft:hard ~hard *)

(** [getrusage] is not implemented because the only meaningful information it
    provides are [ru_utime] and [ru_stime] which can be accessed through 
    [Unix.times].
  *)

END

(** Exit process without running any [at_exit] hooks (implemented in Pervasives) *)
external sys_exit : int -> 'a = "caml_sys_exit"

HAVE MLOCKALL
(**  {2 Memory management} *)

type mlockall_flag = MCL_CURRENT | MCL_FUTURE

(** Lock all pages mapped into the address space of the calling process. *)
external mlockall : mlockall_flag list -> unit = "caml_extunix_mlockall"

(** Unlock all pages mapped into the address space of the calling process. *)
external munlockall : unit -> unit = "caml_extunix_munlockall"

END

HAVE STRTIME
(** {2 Time conversion} *)

(** This function is the converse of the {!strftime} function.
  [strptime fmt data] convert a string containing time information [data]
  into a [tm] struct according to the format specified by [fmt]. *)
external strptime: string -> string -> Unix.tm = "caml_extunix_strptime"

(** Return the ascii representation of a given [tm] argument. The
  ascii time is returned in the form of a string like 
  'Wed Jun 30, 21:21:21 2005\n' *)
external asctime: Unix.tm -> string = "caml_extunix_asctime"

(** This functions is the converse of the {!strptime} function.
  [strftime fmt data] convert a a [tm] structure [data] into a string
  according to the format specified by [fmt]. *)
external strftime: string -> Unix.tm -> string = "caml_extunix_strftime"

(** [tzname isdst] 
  @param isdst specifies whether daylight saving is in effect
  @return abbreviated name of the current timezone
*)
external tzname : bool -> string = "caml_extunix_tzname"

END

HAVE PTS

(** 
  {2 Pseudo terminal management}

  {b Author:} Niki Yoshiuchi <aplusbi\@gmail.com> 
*)

(** This function opens a pseudo-terminal device. *)
external posix_openpt : Unix.open_flag list -> 
  Unix.file_descr = "caml_extunix_posix_openpt"

(** This function grants access to the slave pseudo-terminal. *)
external grantpt: Unix.file_descr -> unit = "caml_extunix_grantpt"

(** This function unlock a pseudo-terminal master/slave pair. *)
external unlockpt: Unix.file_descr -> unit = "caml_extunix_unlockpt"

(** This function get the name of the slave pseudo-terminal. *)
external ptsname: Unix.file_descr -> string = "caml_extunix_ptsname"

END

(* NB Should be after all 'external' definitions *)

(** {2 Meta} *)
(** [have name]
  @return indication whether function [name] is available
  - [Some true] if available
  - [Some false] if not available
  - [None] if not known

  e.g. [have "eventfd"]
*)
SHOW ME THE MONEY

