(** ExtUnix *)

(** [Not_available "func"] may be raised by [ExtUnix.All.func]
    if the wrapped C function is not available on this platform *)
exception Not_available of string

external fsync : Unix.file_descr -> unit = "caml_extunix_fsync"
external fdatasync : Unix.file_descr -> unit = "caml_extunix_fdatasync"

HAVE EVENTFD
external eventfd : int -> Unix.file_descr = "caml_extunix_eventfd"
external eventfd_read : Unix.file_descr -> int64 = "caml_extunix_eventfd_read"
external eventfd_write : Unix.file_descr -> int64 -> unit = "caml_extunix_eventfd_write"
END

HAVE DIRFD
external dirfd : Unix.dir_handle -> Unix.file_descr = "caml_extunix_dirfd"
END

HAVE STATVFS
type statvfs = { vfs_bsize : int; vfs_blocks : int64; vfs_bfree : int64; vfs_inodes : int64; vfs_ifree : int64; }
external statvfs : string -> statvfs = "caml_extunix_statvfs"
external fstatvfs : Unix.file_descr -> statvfs = "caml_extunix_fstatvfs"
END

HAVE ATFILE
external fstatat : Unix.file_descr -> string -> Unix.stats = "caml_extunix_fstatat"
external unlinkat : Unix.file_descr -> string -> unit = "caml_extunix_unlinkat"
external openat : Unix.file_descr -> string -> Unix.open_flag list -> Unix.file_perm -> Unix.file_descr = "caml_extunix_openat"
END

HAVE UNAME

(** uname
    @author Sylvain Le Gall [sylvain\@le-gall.net]
  *)
module Uname = struct
type t =
    {
      sysname:    string;
      nodename:   string;
      release:    string;
      version:    string;
      machine:    string;
    }

let to_string t =
  String.concat " " [ t.sysname; t.nodename; t.release; t.version; t.machine ]
end

external uname : unit -> Uname.t = "caml_extunix_uname"

END

HAVE FADVISE

(** {2 posix_fadvise} *)
(** @author Sylvain Le Gall *)

type advice =
  | POSIX_FADV_NORMAL     (** Indicates that the application has no advice to
                              give about its access pattern for the specified
                              data.  *)
  | POSIX_FADV_SEQUENTIAL (** The application expects to access the specified
                              data sequentially.  *)
  | POSIX_FADV_RANDOM     (** The specified data will be accessed in random
                              order.  *)
  | POSIX_FADV_NOREUSE    (** The specified data will be accessed only once.  *)
  | POSIX_FADV_WILLNEED   (** The specified data will be accessed in the near
                              future.  *) 
  | POSIX_FADV_DONTNEED   (** The specified data will not be accessed in the
                              near future.  *)

(**/**) (*camlp4 misplaces comments*) (**/**)

external fadvise: Unix.file_descr -> int -> int -> advice -> unit = "caml_extunix_fadvise"

END

HAVE FALLOCATE

(** {2 posix_fallocate} *)
(** Allocate disk space for file
    @author Sylvain Le Gall
  *)

(** [fallocate fd off len] allocates disk space to ensure that subsequent writes
    between [off] and [off + len] in [fd] will not fail because of lack of disk 
    space. The file size is modified if [off + len] is bigger than the current size.
  *)
external fallocate: Unix.file_descr -> int -> int -> unit = "caml_extunix_fallocate"

END

(** File operations on large files *)
module LargeFile =
struct

HAVE FADVISE
  external fadvise: Unix.file_descr -> int64 -> int64 -> advice -> unit = "caml_extunix_fadvise64"
END

HAVE FALLOCATE
  external fallocate: Unix.file_descr -> int64 -> int64 -> unit = "caml_extunix_fallocate64"
END

end

(** {2 ioctl} *)

(** Control the underlying device parameters of special files *)
module Ioctl = struct

HAVE SIOCGIFCONF
(** [siocgifconf sock], where [sock] is any socket, e.g. [socket PF_INET SOCK_DGRAM 0]
  @return the list of interfaces and corresponfing addresses *)
external siocgifconf : sock:Unix.file_descr -> (string * string) list = "caml_extunix_ioctl_siocgifconf"
END

HAVE TTY_IOCTL

(** Enable RTS/CTS (hardware) flow control. See CRTSCTS in tcsetattr(3). 
    {b FIXME this is likely to disappear when separate interface for [tcsetattr] and [tcgetattr] gets implemented} *)
external crtscts : Unix.file_descr -> int = "caml_extunix_crtscts"

(** Get the status of modem bits. See TIOCMGET in tty_ioctl(4). *)
external tiocmget : Unix.file_descr -> int = "caml_extunix_ioctl_TIOCMGET"

(** Set the status of modem bits. See TIOCMSET in tty_ioctl(4). *)
external tiocmset : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMSET"

(** Clear the indicated modem bits. See TIOCMBIC in tty_ioctl(4). *)
external tiocmbic : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIC"

(** Set the indicated modem bits. See TIOCMBIS in tty_ioctl(4). *)
external tiocmbis : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIS"

END

end (* module Ioctl *)

HAVE TTYNAME
external ttyname : Unix.file_descr -> string = "caml_extunix_ttyname"
END

HAVE PGID

(** [setpgid pid pgid] sets the process group of the process specified by [pid] to [pgid].
    If [pid] is zero, then the process ID of the calling process is used. If
    [pgid] is zero, then the PGID of the process specified by [pid] is made the same as its process ID. *)
external setpgid : int -> int -> unit = "caml_extunix_setpgid"

(** [getpgid pid] returns the PGID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getpgid : int -> int = "caml_extunix_getpgid"

END

HAVE SETREUID

(** [setreuid ruid euid] sets real and effective user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setreuid(2)" manual *)
external setreuid : int -> int -> unit = "caml_extunix_setreuid"

(** [setregid rgid egid] sets real and effective group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setregid(2)" manual *)
external setregid : int -> int -> unit = "caml_extunix_setregid"

END

