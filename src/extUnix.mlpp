(** ExtUnix *)

(** [Not_available "func"] may be raised by [ExtUnix.All.func]
    if the wrapped C function is not available on this platform *)
exception Not_available of string

HAVE FSYNC
external fsync : Unix.file_descr -> unit = "caml_extunix_fsync"
external fdatasync : Unix.file_descr -> unit = "caml_extunix_fdatasync"
END

HAVE EVENTFD
external eventfd : int -> Unix.file_descr = "caml_extunix_eventfd"
external eventfd_read : Unix.file_descr -> int64 = "caml_extunix_eventfd_read"
external eventfd_write : Unix.file_descr -> int64 -> unit = "caml_extunix_eventfd_write"
END

HAVE DIRFD
external dirfd : Unix.dir_handle -> Unix.file_descr = "caml_extunix_dirfd"
END

HAVE STATVFS
type statvfs = { vfs_bsize : int; vfs_blocks : int64; vfs_bfree : int64; vfs_inodes : int64; vfs_ifree : int64; }
external statvfs : string -> statvfs = "caml_extunix_statvfs"
external fstatvfs : Unix.file_descr -> statvfs = "caml_extunix_fstatvfs"
END

HAVE ATFILE
external openat : Unix.file_descr -> string -> Unix.open_flag list -> Unix.file_perm -> Unix.file_descr = "caml_extunix_openat"
external fstatat : Unix.file_descr -> string -> Unix.stats = "caml_extunix_fstatat"
external unlinkat : Unix.file_descr -> string -> bool -> unit = "caml_extunix_unlinkat"
let unlinkat dirfd ?(rmdir=false) name = unlinkat dirfd name rmdir
external renameat : Unix.file_descr -> string -> Unix.file_descr -> string -> unit = "caml_extunix_renameat"
external mkdirat : Unix.file_descr -> string -> int -> unit = "caml_extunix_mkdirat"
END

HAVE UNAME

(** uname
    @author Sylvain Le Gall [sylvain\@le-gall.net]
  *)
module Uname = struct
type t =
    {
      sysname:    string;
      nodename:   string;
      release:    string;
      version:    string;
      machine:    string;
    }

let to_string t =
  String.concat " " [ t.sysname; t.nodename; t.release; t.version; t.machine ]
end

external uname : unit -> Uname.t = "caml_extunix_uname"

END

HAVE FADVISE

(** {2 posix_fadvise}

{b Author:} Sylvain Le Gall *)

type advice =
  | POSIX_FADV_NORMAL     (** Indicates that the application has no advice to
                              give about its access pattern for the specified
                              data.  *)
  | POSIX_FADV_SEQUENTIAL (** The application expects to access the specified
                              data sequentially.  *)
  | POSIX_FADV_RANDOM     (** The specified data will be accessed in random
                              order.  *)
  | POSIX_FADV_NOREUSE    (** The specified data will be accessed only once.  *)
  | POSIX_FADV_WILLNEED   (** The specified data will be accessed in the near
                              future.  *) 
  | POSIX_FADV_DONTNEED   (** The specified data will not be accessed in the
                              near future.  *)

(**/**) (*camlp4 misplaces comments*) (**/**)

external fadvise: Unix.file_descr -> int -> int -> advice -> unit = "caml_extunix_fadvise"

END

HAVE FALLOCATE

(** {2 posix_fallocate} *)
(** Allocate disk space for file

    {b Author:} Sylvain Le Gall
  *)

(** [fallocate fd off len] allocates disk space to ensure that subsequent writes
    between [off] and [off + len] in [fd] will not fail because of lack of disk 
    space. The file size is modified if [off + len] is bigger than the current size.
  *)
external fallocate: Unix.file_descr -> int -> int -> unit = "caml_extunix_fallocate"

END

(** File operations on large files *)
module LargeFile =
struct

HAVE FADVISE
  external fadvise: Unix.file_descr -> int64 -> int64 -> advice -> unit = "caml_extunix_fadvise64"
END

HAVE FALLOCATE
  external fallocate: Unix.file_descr -> int64 -> int64 -> unit = "caml_extunix_fallocate64"
END

end

(** {2 ioctl} *)

(** Control the underlying device parameters of special files *)
module Ioctl = struct

HAVE SIOCGIFCONF
(** [siocgifconf sock], where [sock] is any socket, e.g. [socket PF_INET SOCK_DGRAM 0]
  @return the list of interfaces and corresponfing addresses *)
external siocgifconf : sock:Unix.file_descr -> (string * string) list = "caml_extunix_ioctl_siocgifconf"
END

HAVE TTY_IOCTL

(** Enable RTS/CTS (hardware) flow control. See CRTSCTS in tcsetattr(3). 
    {b FIXME this is likely to disappear when separate interface for [tcsetattr] and [tcgetattr] gets implemented} *)
external crtscts : Unix.file_descr -> int = "caml_extunix_crtscts"

(** Get the status of modem bits. See TIOCMGET in tty_ioctl(4). *)
external tiocmget : Unix.file_descr -> int = "caml_extunix_ioctl_TIOCMGET"

(** Set the status of modem bits. See TIOCMSET in tty_ioctl(4). *)
external tiocmset : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMSET"

(** Clear the indicated modem bits. See TIOCMBIC in tty_ioctl(4). *)
external tiocmbic : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIC"

(** Set the indicated modem bits. See TIOCMBIS in tty_ioctl(4). *)
external tiocmbis : Unix.file_descr -> int -> unit = "caml_extunix_ioctl_TIOCMBIS"

END

end (* module Ioctl *)

(** {2 Miscellaneous} *)

HAVE TTYNAME
external ttyname : Unix.file_descr -> string = "caml_extunix_ttyname"
END

HAVE PGID

(** [setpgid pid pgid] sets the process group of the process specified by [pid] to [pgid].
    If [pid] is zero, then the process ID of the calling process is used. If
    [pgid] is zero, then the PGID of the process specified by [pid] is made the same as its process ID. *)
external setpgid : int -> int -> unit = "caml_extunix_setpgid"

(** [getpgid pid] returns the PGID of the process specified by [pid].
    If [pid] is zero, the process ID of the calling process is used. *)
external getpgid : int -> int = "caml_extunix_getpgid"

END

HAVE SETREUID

(** [setreuid ruid euid] sets real and effective user IDs of the calling process.
    Supplying a value of -1 for either the real or effective user ID forces the system to leave that ID unchanged. 
    @see "setreuid(2)" manual *)
external setreuid : int -> int -> unit = "caml_extunix_setreuid"

(** [setregid rgid egid] sets real and effective group IDs of the calling process.
    Supplying a value of -1 for either the real or effective group ID forces the system to leave that ID unchanged. 
    @see "setregid(2)" manual *)
external setregid : int -> int -> unit = "caml_extunix_setregid"

END

HAVE REALPATH
(** [realpath path]
    @return the canonicalized absolute pathname of [path]
    @see "realpath(2)" manual *)
external realpath : string -> string = "caml_extunix_realpath"
END

HAVE SIGNALFD

(** {2 signalfd} *)

(** OCaml bindings for signalfd(2) and related functions

    {b Author:} Kaustuv Chaudhuri <kaustuv.chaudhuri\@inria.fr>
*)

(******************************************************************************)
(* signalfd bindings                                                          *)
(*                                                                            *)
(* NO COPYRIGHT -- RELEASED INTO THE PUBLIC DOMAIN                            *)
(*                                                                            *)
(* Author: Kaustuv Chaudhuri <kaustuv.chaudhuri@inria.fr>                     *)
(******************************************************************************)

(** [signalfd ?fd sigs flags ()]
    If the first optional argument is omitted, then a new file descriptor is allocated.
    Otherwise, the given file descriptor is modified (in which case it
    must have been created with [signalfd] previously). When you are
    done with the fd, remember to {!Unix.close} it. Do not forget
    to block [sigs] with {!Unix.sigprocmask} to prevent signal handling
    according to default dispositions.
    @see "signalfd(2)" manual
    *)
external signalfd : ?fd:Unix.file_descr -> sigs:int list -> flags:int list -> unit -> Unix.file_descr ="caml_extunix_signalfd"

(** This type represents signal information that is read(2) from the
    signalfd. *)
type ssi

(** Blocking read(2) on a signalfd. Has undefined behaviour on
    non-signalfds. Every successful read consumes a pending signal. *)
external signalfd_read    : Unix.file_descr -> ssi = "caml_extunix_signalfd_read"

(** {6 Functions to query the signal information structure.} *)

(** Get the signal value. This form is compatible with the signal
    values defined in the standard {!Sys} module.

    See signalfd(2) for the details of the remaining functions. Most
    of these integers are actually unsigned. *)
external ssi_signo_sys    : ssi -> int   = "caml_extunix_ssi_signo_sys"

external ssi_signo        : ssi -> int32 = "caml_extunix_ssi_signo"
external ssi_errno        : ssi -> int32 = "caml_extunix_ssi_errno"
external ssi_code         : ssi -> int32 = "caml_extunix_ssi_code"
external ssi_pid          : ssi -> int32 = "caml_extunix_ssi_pid"
external ssi_uid          : ssi -> int32 = "caml_extunix_ssi_uid"
external ssi_fd           : ssi -> Unix.file_descr = "caml_extunix_ssi_fd"
external ssi_tid          : ssi -> int32 = "caml_extunix_ssi_tid"
external ssi_band         : ssi -> int32 = "caml_extunix_ssi_band"
external ssi_overrun      : ssi -> int32 = "caml_extunix_ssi_overrun"
external ssi_trapno       : ssi -> int32 = "caml_extunix_ssi_trapno"
external ssi_status       : ssi -> int32 = "caml_extunix_ssi_status"
external ssi_int          : ssi -> int32 = "caml_extunix_ssi_int"
external ssi_ptr          : ssi -> int64 = "caml_extunix_ssi_ptr"
external ssi_utime        : ssi -> int64 = "caml_extunix_ssi_utime"
external ssi_stime        : ssi -> int64 = "caml_extunix_ssi_stime"
external ssi_addr         : ssi -> int64 = "caml_extunix_ssi_addr"

END

